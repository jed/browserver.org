{
  "name": "brow",
  "version": "0.0.3",
  "description": "෴ A browserver proxy for node.js ෴",
  "main": "browserver.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/jed/browserver-node.git"
  },
  "keywords": [
    "websocket",
    "http",
    "server",
    "browser",
    "webhook"
  ],
  "author": {
    "name": "Jed Schmidt"
  },
  "license": "BSD",
  "dependencies": {
    "brow-client": "0.0.x"
  },
  "devDependencies": {
    "ws": "~0.4.21",
    "tap": "~0.3.0"
  },
  "scripts": {
    "test": "tap --tap test/server.js"
  },
  "readme": "෴ browserver-node ෴\n======================\n\nThis is a [browserver](http://browserver.org) proxy for [node.js](http://nodejs.org).\n\nUse browserver-node to create servers that act as a two-way proxies between an HTTP server and a WebSocket server, by\n\n- forwarding incoming HTTP requests on to WebSocket connected clients, and back.\n- forwarding incoming WebSocket messages to other HTTP servers, and back.\n\nThis library, along with [browserver-client](https://github.com/jed/browserver-client), is all the code you need to set up your own browserver.\n\nExample\n-------\n\n```javascript\n// http, websocket, and browservers\nvar http   = require(\"http\")\nvar engine = require(\"engine.io\")\nvar brow   = require(\"brow\")\n\nfunction handler(req, res) {\n  // your usual HTTP server logic\n}\n\n// instantiate http and websocket servers\nvar httpServer = http.createServer(handler)\nvar wsServer   = engine.attach(httpServer)\n\n// pass each to a new browserver...\nvar browServer = new brow.Server({\n  http: httpServer,\n  ws: wsServer,\n  host: \"*.mydomain.org\"\n})\n\n// ... and start listening!\nhttpServer.listen(80, function() {\n  // wait for incoming/outgoing browser connections...\n})\n```\n\nInstallation\n------------\n\nbrowserver is available through npm.\n\n`npm install brow`\n\nAPI\n---\n\n### browserver = new brow.Server(options)\n\nThis joins a WebSocket server and HTTP server, returning a new browserver instance. The `options` argument accepts the following properties:\n\n- `ws`: Required. Must be an instance of a WebSocket server (such as [ws](https://github.com/einaros/ws)) or compatible shim (such as [socket.io](https://github.com/learnboost/socket.io), [engine.io](https://github.com/learnboost/engine.io)) that emits socket instances through `connection` events.\n\n- `http`: Optional. If specified, must be an instance of `http.Server`. If omitted, an instance will be instantiated and bound to port `3572` (the Unicode codepoint for the brow `෴`).\n\n- `host` Optional. If specified, must be a string containing one and only one asterisk (`*`), which is replaced with a socket id when a WebSocket connection is established. Note that this means you will need a wildcard CNAME or A record in your DNS settings that resolves to the appropriate domain or IP address. If omitted, CloudFoundry's [*.vcap.me](https://github.com/cloudfoundry/vcap/) domain is used, which resolves all domains/subdomains to `127.0.0.1`.\n\n### browserver.on(\"connection\", function(client){ ... })\n\nThe browserver server emits a `connection` event with a WebSocket-connected browserver client, whenever one connects. Each client is an instance of `brow.Client`, with an `id` property that defaults to a random lowercase alphanumeric string generated upon instantiation. How these ids are generated can be customized by overriding the static `brow.Client.id` method.\n\n### client.on(\"close\", function(){ ... })\n\nbrowserver clients emit a `close` event when their underlying WebSocket is closed.\n\nTODO\n----\n\n- Add integrated hooks for authorization and authentication of requests, both incoming and outgoing.\n- Finish filling out phantomjs tests, and put them on travis-ci.\n- Consider using the standard HTTP format instead of JSON for communication.\n",
  "_id": "brow@0.0.3",
  "dist": {
    "shasum": "f8648207d7eace71d13796dab4b7d95055426b9a"
  },
  "_from": "brow@0.0.3"
}
